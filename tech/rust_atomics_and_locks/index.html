

<!DOCTYPE html>
<html lang="en" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="/img/morty.jpeg">
  <link rel="icon" href="/img/morty.jpeg">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="kayce">
  <meta name="keywords" content="">
  
    <meta name="description" content="(WIP) POV - Rust Atomics and Locks">
<meta property="og:type" content="article">
<meta property="og:title" content="Rust Atomics and Locks">
<meta property="og:url" content="https://kayce.world/tech/rust_atomics_and_locks/index.html">
<meta property="og:site_name" content="kayce">
<meta property="og:description" content="(WIP) POV - Rust Atomics and Locks">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2024-12-18T08:01:50.000Z">
<meta property="article:modified_time" content="2024-12-18T10:35:50.000Z">
<meta property="article:author" content="kayce">
<meta property="article:tag" content="Rust">
<meta name="twitter:card" content="summary_large_image">
  
  
    <meta name="referrer" content="no-referrer-when-downgrade">
  
  
  <title>Rust Atomics and Locks - kayce</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"kayce.world","root":"/","version":"1.9.8","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":null,"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null},"gtag":null,"woyaola":null,"cnzz":null},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 7.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>kayce&#39;s world</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>Home</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>Archives</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>Categories</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>Tags</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/music/" target="_self">
                <i class="iconfont icon-music"></i>
                <span>Music</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>About</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/RanchoNight_16_Tree.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="Rust Atomics and Locks"></span>
          
        </div>

        
          
  <div class="mt-3">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-author" aria-hidden="true"></i>
        kayce
      </span>
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2024-12-18 16:01" pubdate>
          December 18, 2024 pm
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    

    

    
    
      
        <span id="busuanzi_container_page_pv" style="display: none">
          <i class="iconfont icon-eye" aria-hidden="true"></i>
          <span id="busuanzi_value_page_pv"></span> views
        </span>
        

      
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">Rust Atomics and Locks</h1>
            
              <p id="updated-time" class="note note-info" style="">
                
                  
                    Last updated on December 18, 2024 pm
                  
                
              </p>
            
            
              <div class="markdown-body">
                
                <div class="note note-warning">
            <p>WIP, No ETA provided</p>
          </div>
<blockquote>
<p>The <strong><em>tremendous</em></strong> book<br>
<a target="_blank" rel="noopener" href="https://marabos.nl/atomics/"><em>Rust Atomics and Locks</em></a> by <a target="_blank" rel="noopener" href="https://marabos.nl/">Mara Bos</a><br>
in my POV.</p>
</blockquote>
<h2 id="Cell-RefCell">Cell, RefCell</h2>
<p><strong><em>Interior mutability</em></strong>: a design pattern in Rust that allows you to mutate data even when there are immutable references to that data.</p>
<p>In short, you can use <code>fn foo(&amp;self)</code> to change the data inside the struct. Normally, we have to use <code>fn foo(&amp;mut self)</code>.</p>
<p><strong>Cell</strong></p>
<ul>
<li><code>take()</code> out the data, modify it, and <code>set()</code> it back.
<blockquote>
<p><code>Mutex</code> is the concurrent version of <code>Cell</code>.</p>
</blockquote>
</li>
</ul>
<p><strong>Refcell:</strong></p>
<ul>
<li><code>borrow_mut()</code> will panic if there’s already a mutable borrow.
<blockquote>
<p><code>RWMutex</code> is the concurrent version of <code>RefCell</code>, but it will block until the mutable borrow is released instead of panicking.</p>
</blockquote>
</li>
</ul>
<div class="note note-light">
            <p><strong>Aside: UnsafeCell</strong><br>Both of them are built with a core primitive called <code>UnsafeCell</code>.</p><p>This struct provides the basic abstraction for interior mutability, however, you have to use <code>unsafe</code> to access.</p><p><code>Cell</code>, <code>RefCell</code> and all other types that allows internal mutability use <code>UnsafeCell</code> to wrap their data and provide <code>safe</code> apis.</p>
          </div>
<h2 id="MutexGuard-lifetime">MutexGuard lifetime</h2>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">if</span> list.<span class="hljs-title function_ invoke__">lock</span>().<span class="hljs-title function_ invoke__">unwrap</span>().<span class="hljs-title function_ invoke__">pop</span>() == <span class="hljs-title function_ invoke__">Some</span>(<span class="hljs-number">1</span>) &#123; <span class="hljs-comment">// &lt;--- drop here</span><br>    <span class="hljs-title function_ invoke__">do_something</span>();<br>&#125;<br><br><span class="hljs-comment">// PERF: needlessly hold on to the lock while processing the item.</span><br><span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-variable">Some</span>(item) = list.<span class="hljs-title function_ invoke__">lock</span>().<span class="hljs-title function_ invoke__">unwrap</span>().<span class="hljs-title function_ invoke__">pop</span>() &#123;<br>    <span class="hljs-title function_ invoke__">process_item</span>(item);<br>&#125; <span class="hljs-comment">// &lt;--- drop here</span><br><br><span class="hljs-comment">// FIXED:</span><br><span class="hljs-keyword">let</span> <span class="hljs-variable">item</span> = list.<span class="hljs-title function_ invoke__">lock</span>().<span class="hljs-title function_ invoke__">unwrap</span>().<span class="hljs-title function_ invoke__">pop</span>(); <span class="hljs-comment">// &lt;--- drop here</span><br><span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-variable">Some</span>(item) = item &#123;<br>    <span class="hljs-title function_ invoke__">process_item</span>(item);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>Reason:</p>
<ul>
<li>The basic <code>if</code> statement is always a simple <code>boolean</code> expression.</li>
<li>If we replace <code>pop()</code> with <code>front()</code>, things’re clear. That’s how borrow checker works.</li>
</ul>
<h2 id="Parking">Parking</h2>
<p>Consider this situation: we only process items when the list is not empty.<br>
If we use <code>Mutex</code>, then we have to keep calling <code>lock()</code> again and again, which is not efficient.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::collections::VecDeque;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">queue</span> = Mutex::<span class="hljs-title function_ invoke__">new</span>(VecDeque::<span class="hljs-title function_ invoke__">new</span>());<br><br>    thread::<span class="hljs-title function_ invoke__">scope</span>(|s| &#123;<br>        <span class="hljs-comment">// Consuming thread</span><br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">t</span> = s.<span class="hljs-title function_ invoke__">spawn</span>(|| <span class="hljs-keyword">loop</span> &#123;<br>            <span class="hljs-keyword">let</span> <span class="hljs-variable">item</span> = queue.<span class="hljs-title function_ invoke__">lock</span>().<span class="hljs-title function_ invoke__">unwrap</span>().<span class="hljs-title function_ invoke__">pop_front</span>();<br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-variable">Some</span>(item) = item &#123;<br>                dbg!(item);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                thread::<span class="hljs-title function_ invoke__">park</span>();<br>            &#125;<br>        &#125;);<br><br>        <span class="hljs-comment">// Producing thread</span><br>        <span class="hljs-keyword">for</span> <span class="hljs-variable">i</span> <span class="hljs-keyword">in</span> <span class="hljs-number">0</span>.. &#123;<br>            queue.<span class="hljs-title function_ invoke__">lock</span>().<span class="hljs-title function_ invoke__">unwrap</span>().<span class="hljs-title function_ invoke__">push_back</span>(i);<br>            t.<span class="hljs-title function_ invoke__">thread</span>().<span class="hljs-title function_ invoke__">unpark</span>();<br>            thread::<span class="hljs-title function_ invoke__">sleep</span>(Duration::<span class="hljs-title function_ invoke__">from_secs</span>(<span class="hljs-number">1</span>));<br>        &#125;<br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure>
<div class="note note-primary">
            <p>A call to <code>unpark()</code> before the thread parks itself <strong><em>does not get lost</em></strong></p><p>However, unpark requests <strong><em>don’t stack up</em></strong>.</p><p>Calling unpark() two times and then calling park() two times afterwards still results in the thread going to sleep.</p>
          </div>
<h2 id="Cond-Vars">Cond Vars</h2>
<p>The example above is low-efficiency when we want to use more consumers.<br>
Because the producer doesn’t know which consumer to wake up.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">use</span> std::sync::Condvar;<br>    <span class="hljs-keyword">use</span> std::&#123;collections::VecDeque, sync::Mutex, thread, time::Duration&#125;;<br><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">queue</span> = Mutex::<span class="hljs-title function_ invoke__">new</span>(VecDeque::<span class="hljs-title function_ invoke__">new</span>());<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">not_empty</span> = Condvar::<span class="hljs-title function_ invoke__">new</span>();<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">empty</span> = Condvar::<span class="hljs-title function_ invoke__">new</span>();<br><br>    thread::<span class="hljs-title function_ invoke__">scope</span>(|s| &#123;<br>        <span class="hljs-comment">// not_empty handler</span><br>        s.<span class="hljs-title function_ invoke__">spawn</span>(|| <span class="hljs-keyword">loop</span> &#123;<br>            <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">q</span> = queue.<span class="hljs-title function_ invoke__">lock</span>().<span class="hljs-title function_ invoke__">unwrap</span>();<br>            <span class="hljs-keyword">let</span> <span class="hljs-variable">item</span> = <span class="hljs-keyword">loop</span> &#123;<br>                <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-variable">Some</span>(item) = q.<span class="hljs-title function_ invoke__">pop_front</span>() &#123;<br>                    <span class="hljs-keyword">break</span> item;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    empty.<span class="hljs-title function_ invoke__">notify_one</span>(); <span class="hljs-comment">// wake up the empty handler(s)</span><br>                    q = not_empty.<span class="hljs-title function_ invoke__">wait</span>(q).<span class="hljs-title function_ invoke__">unwrap</span>();<br>                &#125;<br>            &#125;;<br>            <span class="hljs-title function_ invoke__">drop</span>(q);<br>            <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Got item: &#123;&#125;&quot;</span>, item);<br>        &#125;);<br><br>        <span class="hljs-comment">// empty handler</span><br>        s.<span class="hljs-title function_ invoke__">spawn</span>(|| <span class="hljs-keyword">loop</span> &#123;<br>            <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">q</span> = queue.<span class="hljs-title function_ invoke__">lock</span>().<span class="hljs-title function_ invoke__">unwrap</span>();<br>            <span class="hljs-keyword">loop</span> &#123;<br>                <span class="hljs-keyword">if</span> q.<span class="hljs-title function_ invoke__">is_empty</span>() &#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    q = empty.<span class="hljs-title function_ invoke__">wait</span>(q).<span class="hljs-title function_ invoke__">unwrap</span>();<br>                &#125;<br>            &#125;<br>            <span class="hljs-title function_ invoke__">drop</span>(q);<br>            <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Queue is empty&quot;</span>);<br>            thread::<span class="hljs-title function_ invoke__">sleep</span>(Duration::<span class="hljs-title function_ invoke__">from_millis</span>(<span class="hljs-number">400</span>));<br>        &#125;);<br><br>        <span class="hljs-comment">// producer</span><br>        <span class="hljs-keyword">for</span> <span class="hljs-variable">i</span> <span class="hljs-keyword">in</span> <span class="hljs-number">0</span>.. &#123;<br>            queue.<span class="hljs-title function_ invoke__">lock</span>().<span class="hljs-title function_ invoke__">unwrap</span>().<span class="hljs-title function_ invoke__">push_back</span>(i);<br>            not_empty.<span class="hljs-title function_ invoke__">notify_one</span>(); <span class="hljs-comment">// wake up the not_empty handler(s)</span><br>            thread::<span class="hljs-title function_ invoke__">sleep</span>(Duration::<span class="hljs-title function_ invoke__">from_secs</span>(<span class="hljs-number">1</span>));<br>        &#125;<br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="Memory-Ordering">Memory Ordering</h2>
<h3 id="Relaxed">Relaxed</h3>
<p>While atomic operations using relaxed memory ordering do not provide any happens-before relationship,<br>
they do guarantee a total modification order of each individual atomic variable.<br>
This means that all modifications of the same atomic variable happen in an order that is the same from the perspective of every single thread.</p>
<p>Example:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">static</span> X: AtomicI32 = AtomicI32::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-number">0</span>);<br><br><span class="hljs-comment">// thread 1</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">a</span>() &#123;<br>    X.<span class="hljs-title function_ invoke__">fetch_add</span>(<span class="hljs-number">5</span>, Relaxed);<br>    X.<span class="hljs-title function_ invoke__">fetch_add</span>(<span class="hljs-number">10</span>, Relaxed);<br>&#125;<br><br><span class="hljs-comment">// thread 2</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">b</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">a</span> = X.<span class="hljs-title function_ invoke__">load</span>(Relaxed);<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">b</span> = X.<span class="hljs-title function_ invoke__">load</span>(Relaxed);<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">c</span> = X.<span class="hljs-title function_ invoke__">load</span>(Relaxed);<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">d</span> = X.<span class="hljs-title function_ invoke__">load</span>(Relaxed);<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;a&#125; &#123;b&#125; &#123;c&#125; &#123;d&#125;&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>The output will never be <code>0 5 0 15</code> or <code>0 0 10 15</code> due to the order of the 2 <code>fetch_add</code> ops.</p>
<ul>
<li><code>0 5 0 15</code>: since we’ve written 5 and it has been read, the next read mustn’t be 0.</li>
<li><code>0 0 10 15</code>: write 5 happens before write 10.</li>
</ul>
<hr>
<h3 id="Release-Acquire">Release / Acquire</h3>
<p><code>Release</code> corresponds to the <code>store</code> operation, and <code>Acquire</code> corresponds to the <code>load</code> operation.</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::sync::atomic::Ordering::&#123;Acquire, Release&#125;;<br><br><span class="hljs-keyword">static</span> DATA: AtomicU64 = AtomicU64::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-number">0</span>);<br><span class="hljs-keyword">static</span> READY: AtomicBool = AtomicBool::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-literal">false</span>);<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    thread::<span class="hljs-title function_ invoke__">spawn</span>(|| &#123;<br>        DATA.<span class="hljs-title function_ invoke__">store</span>(<span class="hljs-number">123</span>, Relaxed);<br>        READY.<span class="hljs-title function_ invoke__">store</span>(<span class="hljs-literal">true</span>, Release); <span class="hljs-comment">// Everything from before this store ..</span><br>    &#125;);<br>    <span class="hljs-keyword">while</span> !READY.<span class="hljs-title function_ invoke__">load</span>(Acquire) &#123; <span class="hljs-comment">// .. is visible after this loads `true`.</span><br>        thread::<span class="hljs-title function_ invoke__">sleep</span>(Duration::<span class="hljs-title function_ invoke__">from_millis</span>(<span class="hljs-number">100</span>));<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;waiting...&quot;</span>);<br>    &#125;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, DATA.<span class="hljs-title function_ invoke__">load</span>(Relaxed));<br>&#125;<br></code></pre></td></tr></table></figure>
<div class="note note-info">
            <p>Note that if we use <code>Relaxed</code> instead of <code>Acquire</code> for <code>READY</code>, we might read <code>0</code> instead of <code>123</code>.<br>That’s because <code>Relaxed</code> only provides a total order for the <strong><em>same</em></strong> atomic variable, not across <strong><em>different</em></strong> variables.</p>
          </div>
<p>Since <code>Release</code> and <code>Acquire</code> have a happens-before relationship, we can simply use <code>u64</code> instead of <code>AtomicU64</code>:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">static</span> <span class="hljs-keyword">mut</span> DATA: <span class="hljs-type">u64</span> = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">static</span> READY: AtomicBool = AtomicBool::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-literal">false</span>);<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    thread::<span class="hljs-title function_ invoke__">spawn</span>(|| &#123;<br>        <span class="hljs-comment">// Safety: Nothing else is accessing DATA,</span><br>        <span class="hljs-comment">// because we haven&#x27;t set the READY flag yet.</span><br>        <span class="hljs-keyword">unsafe</span> &#123; DATA = <span class="hljs-number">123</span> &#125;;<br>        READY.<span class="hljs-title function_ invoke__">store</span>(<span class="hljs-literal">true</span>, Release); <span class="hljs-comment">// Everything from before this store ..</span><br>    &#125;);<br>    <span class="hljs-keyword">while</span> !READY.<span class="hljs-title function_ invoke__">load</span>(Acquire) &#123;<br>        <span class="hljs-comment">// .. is visible after this loads `true`.</span><br>        thread::<span class="hljs-title function_ invoke__">sleep</span>(Duration::<span class="hljs-title function_ invoke__">from_millis</span>(<span class="hljs-number">100</span>));<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;waiting...&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">// Safety: Nothing is mutating DATA, because READY is set.</span><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, <span class="hljs-keyword">unsafe</span> &#123; DATA &#125;);<br>&#125;<br></code></pre></td></tr></table></figure>
<hr>
<h3 id="SeqCst">SeqCst</h3>
<p>To be short, the order of excution is just like the order of the codes.<br>
Here’s a example of the difference between <code>Acq/Rel</code> and <code>SeqCst</code>:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">static</span> A: AtomicUsize = AtomicUsize::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-number">0</span>);<br><span class="hljs-keyword">static</span> B: AtomicUsize = AtomicUsize::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-number">0</span>);<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">thread1</span>() &#123;<br>    A.<span class="hljs-title function_ invoke__">store</span>(<span class="hljs-number">1</span>, SeqCst);<br>    B.<span class="hljs-title function_ invoke__">store</span>(<span class="hljs-number">2</span>, SeqCst);<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">thread2</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">b</span> = B.<span class="hljs-title function_ invoke__">load</span>(SeqCst);<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">a</span> = A.<span class="hljs-title function_ invoke__">load</span>(SeqCst);<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;a = &#123;&#125;, b = &#123;&#125;&quot;</span>, a, b);<br>&#125;<br></code></pre></td></tr></table></figure>
<blockquote>
<p>If b is <code>2</code> then a must be <code>1</code>.</p>
</blockquote>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">static</span> A: AtomicUsize = AtomicUsize::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-number">0</span>);<br><span class="hljs-keyword">static</span> B: AtomicUsize = AtomicUsize::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-number">0</span>);<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">thread1</span>() &#123;<br>    A.<span class="hljs-title function_ invoke__">store</span>(<span class="hljs-number">1</span>, Release);<br>    B.<span class="hljs-title function_ invoke__">store</span>(<span class="hljs-number">2</span>, Relaxed);<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">thread2</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">b</span> = B.<span class="hljs-title function_ invoke__">load</span>(Relaxed);<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">a</span> = A.<span class="hljs-title function_ invoke__">load</span>(Acquire);<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;a = &#123;&#125;, b = &#123;&#125;&quot;</span>, a, b);<br>&#125;<br></code></pre></td></tr></table></figure>
<blockquote>
<p>If b is <code>2</code>, we can’t guarantee that a is <code>1</code>.</p>
</blockquote>
<hr>
<h3 id="Fence">Fence</h3>
<p>To be short, <code>fence</code> stops the compiler from reordering instructions following the fence with instructions preceding the fence.</p>
<ol>
<li><code>fence</code> after <code>load</code>:</li>
</ol>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// Thread A</span><br>&#123;<br>    DATA.<span class="hljs-title function_ invoke__">store</span>(<span class="hljs-number">42</span>, Relaxed);<br>    READY.<span class="hljs-title function_ invoke__">store</span>(<span class="hljs-literal">true</span>, ??);<br>&#125;<br><br><span class="hljs-comment">// Thread B</span><br><span class="hljs-keyword">if</span> READY.<span class="hljs-title function_ invoke__">load</span>(??) &#123;<br>    <span class="hljs-comment">// fence after</span><br>    <span class="hljs-title function_ invoke__">fence</span>(Acquire);<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">value</span> = DATA.<span class="hljs-title function_ invoke__">load</span>(Relaxed);<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;DATA = &#123;&#125;&quot;</span>, value);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>Let’s say, if we move the <code>fence</code> to the front of the <code>if</code> block, then the compiler <strong><em>might</em></strong> reorder the <code>load</code> before the <code>if</code> check:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// Thread B</span><br><span class="hljs-title function_ invoke__">fence</span>(Acquire);<br><span class="hljs-keyword">let</span> <span class="hljs-variable">value</span> = DATA.<span class="hljs-title function_ invoke__">load</span>(Relaxed);<br><span class="hljs-keyword">if</span> READY.<span class="hljs-title function_ invoke__">load</span>(??) &#123;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;DATA = &#123;&#125;&quot;</span>, value);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>So we’ll get <code>DATA = 0</code> instead of <code>DATA = 42</code>.</p>
<ol start="2">
<li><code>fence</code> before <code>store</code></li>
</ol>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust">&#123;<br>    DATA.<span class="hljs-title function_ invoke__">store</span>(<span class="hljs-number">42</span>, Relaxed);<br>    <span class="hljs-title function_ invoke__">fence</span>(Release); <span class="hljs-comment">// make sure DATA is stored</span><br>    READY.<span class="hljs-title function_ invoke__">store</span>(<span class="hljs-literal">true</span>, Relaxed);<br>&#125;<br></code></pre></td></tr></table></figure>
<hr>
<h3 id="Misconceptions">Misconceptions</h3>
<ol>
<li><strong>I need strong memory ordering to make sure changes are immediately visible to other threads.</strong></li>
</ol>
<ul>
<li>In real life, memory ordering is about things like reordering instructions, which usually happen at nanosecond scale.<br>
Stronger memory ordering does not make your data travel faster; it might even slow your program down.</li>
</ul>
<ol start="2">
<li><strong>Disabling optimization means I don’t need to care about memory ordering.</strong></li>
</ol>
<ul>
<li>Processor optimizations still happen even if you disable compiler optimizations.</li>
</ul>
<ol start="3">
<li><strong>Sequentially consistent memory ordering can be used for a “release-load” or an “acquire-store.”</strong></li>
</ol>
<ul>
<li>Release-store <strong><em>does not</em></strong> form any release-acquire relationship with a SeqCst-store.<br>
If you need them to be part of a globally consistent order, <u>both operations will have to use SeqCst</u>.</li>
</ul>
<hr>
<h3 id="Summary">Summary</h3>
<table>
<thead>
<tr>
<th>type</th>
<th>guarantee</th>
</tr>
</thead>
<tbody>
<tr>
<td>Relaxed</td>
<td>Total modification order of a specific single atomic variable</td>
</tr>
<tr>
<td>Acq/Rel</td>
<td>Make sure changes before “Rel” are visible to “Acq”</td>
</tr>
<tr>
<td>SeqCst</td>
<td>Just like the order of the codes look like</td>
</tr>
<tr>
<td>Fence</td>
<td>Codes after the fence are not reordered with the codes before the fence</td>
</tr>
</tbody>
</table>
<div class="note note-light">
            <p><strong>Aside: <code>compare_exchange</code> vs. <code>compare_exchange_weak</code></strong></p><p>To be short, <code>compare_exchange_weak</code> might return <code>Err</code> even if the comparison is successful.</p><p>This is because the low-level instructions of <code>_weak</code> is <code>LL/SC</code> (Load-Linked/Store-Conditional), which might fail due to cache contention.</p><p>Since we always need to use <code>while</code> loop to retry, <code>compare_exchange_weak</code> is <strong>more efficient</strong> on some specific platforms, such as <code>ARM</code>.</p>
          </div>
<h2 id="Spin-Lock">Spin Lock</h2>
<blockquote>
<p>If a lock is only ever held for very brief moments and the threads locking it can run in parallel on <strong><u>different processor cores</u></strong>,<br>
it might be better for the threads to repeatedly try to lock it without actually going to sleep.</p>
</blockquote>
<h3 id="Minimal-Impl">Minimal Impl</h3>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">impl</span> <span class="hljs-title class_">SpinLock</span> &#123;<br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">new</span>() <span class="hljs-punctuation">-&gt;</span> <span class="hljs-keyword">Self</span> &#123;<br>        <span class="hljs-keyword">Self</span> &#123; locked: AtomicBool::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-literal">false</span>) &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">lock</span>(&amp;<span class="hljs-keyword">self</span>) &#123;<br>        <span class="hljs-keyword">while</span> <span class="hljs-keyword">self</span>.locked.<span class="hljs-title function_ invoke__">swap</span>(<span class="hljs-literal">true</span>, Acquire) &#123;<br>            std::hint::<span class="hljs-title function_ invoke__">spin_loop</span>();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">unlock</span>(&amp;<span class="hljs-keyword">self</span>) &#123;<br>        <span class="hljs-keyword">self</span>.locked.<span class="hljs-title function_ invoke__">store</span>(<span class="hljs-literal">false</span>, Release);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<hr>
<h3 id="Hold-value">Hold value</h3>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">SpinLock</span>&lt;T&gt; &#123;<br>    locked: AtomicBool,<br>    value: UnsafeCell&lt;T&gt;,<br>&#125;<br><br><span class="hljs-keyword">impl</span>&lt;T&gt; SpinLock&lt;T&gt; &#123;<br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">new</span>(value: T) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-keyword">Self</span> &#123;<br>        <span class="hljs-keyword">Self</span> &#123;<br>            locked: AtomicBool::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-literal">false</span>),<br>            value: UnsafeCell::<span class="hljs-title function_ invoke__">new</span>(value),<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// use this macro to suppress the clippy error</span><br>    <span class="hljs-meta">#[allow(clippy::mut_from_ref)]</span><br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">lock</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> &amp;<span class="hljs-keyword">mut</span> T &#123;<br>        <span class="hljs-keyword">while</span> <span class="hljs-keyword">self</span>.locked.<span class="hljs-title function_ invoke__">swap</span>(<span class="hljs-literal">true</span>, Acquire) &#123;<br>            std::hint::<span class="hljs-title function_ invoke__">spin_loop</span>();<br>        &#125;<br>        <span class="hljs-keyword">unsafe</span> &#123; &amp;<span class="hljs-keyword">mut</span> *<span class="hljs-keyword">self</span>.value.<span class="hljs-title function_ invoke__">get</span>() &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">unlock</span>(&amp;<span class="hljs-keyword">self</span>) &#123;<br>        <span class="hljs-keyword">self</span>.locked.<span class="hljs-title function_ invoke__">store</span>(<span class="hljs-literal">false</span>, Release);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<hr>
<h3 id="Use-Guard-to-auto-unlock">Use Guard to auto unlock</h3>
<blockquote>
<p>Ignore the <code>Swift</code> syntax, <code>highlightjs</code> doesn’t handle the rust lifetime specifier properly.</p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs swift">pub <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Guard</span>&lt;&#x27;a, <span class="hljs-type">T</span>&gt; &#123;<br>    lock: <span class="hljs-operator">&amp;</span>&#x27;a <span class="hljs-type">SpinLock</span>&lt;<span class="hljs-type">T</span>&gt;,<br>&#125;<br><br>impl<span class="hljs-operator">&lt;</span><span class="hljs-type">T</span><span class="hljs-operator">&gt;</span> <span class="hljs-type">Deref</span> <span class="hljs-keyword">for</span> <span class="hljs-type">Guard</span>&lt;&#x27;<span class="hljs-keyword">_</span>, <span class="hljs-type">T</span>&gt; &#123;<br>    type <span class="hljs-type">Target</span> <span class="hljs-operator">=</span> <span class="hljs-type">T</span>;<br>    fn deref(<span class="hljs-operator">&amp;</span><span class="hljs-keyword">self</span>) -&gt; <span class="hljs-operator">&amp;</span><span class="hljs-keyword">Self</span>::<span class="hljs-type">Target</span> &#123;<br>        unsafe &#123; <span class="hljs-operator">&amp;*</span><span class="hljs-keyword">self</span>.lock.value &#125;<br>    &#125;<br>&#125;<br><br>impl<span class="hljs-operator">&lt;</span><span class="hljs-type">T</span><span class="hljs-operator">&gt;</span> <span class="hljs-type">DerefMut</span> <span class="hljs-keyword">for</span> <span class="hljs-type">Guard</span>&lt;&#x27;<span class="hljs-keyword">_</span>, <span class="hljs-type">T</span>&gt; &#123;<br>    fn deref_mut(<span class="hljs-operator">&amp;</span>mut <span class="hljs-keyword">self</span>) -&gt; <span class="hljs-operator">&amp;</span>mut <span class="hljs-keyword">Self</span>::<span class="hljs-type">Target</span> &#123;<br>        unsafe &#123; <span class="hljs-operator">&amp;</span>mut <span class="hljs-operator">*</span><span class="hljs-keyword">self</span>.lock.value &#125;<br>    &#125;<br>&#125;<br><br>impl<span class="hljs-operator">&lt;</span><span class="hljs-type">T</span><span class="hljs-operator">&gt;</span> <span class="hljs-type">Drop</span> <span class="hljs-keyword">for</span> <span class="hljs-type">Guard</span>&lt;&#x27;<span class="hljs-keyword">_</span>, <span class="hljs-type">T</span>&gt; &#123;<br>    fn drop(<span class="hljs-operator">&amp;</span>mut <span class="hljs-keyword">self</span>) &#123;<br>        <span class="hljs-keyword">self</span>.lock.unlock();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>Now let’s change the <code>lock</code> method to return a <code>Guard</code>:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">impl</span>&lt;T&gt; SpinLock&lt;T&gt; &#123;<br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">lock</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> Guard&lt;T&gt; &#123;<br>        <span class="hljs-keyword">while</span> <span class="hljs-keyword">self</span>.locked.<span class="hljs-title function_ invoke__">swap</span>(<span class="hljs-literal">true</span>, Acquire) &#123;<br>            std::hint::<span class="hljs-title function_ invoke__">spin_loop</span>();<br>        &#125;<br>        Guard &#123; lock: <span class="hljs-keyword">self</span> &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="Chan">Chan</h2>
<blockquote>
<p>Ignore the <code>Swift</code> syntax, <code>highlightjs</code> doesn’t handle the rust lifetime specifier properly.</p>
</blockquote>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs swift">pub <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Channel</span>&lt;<span class="hljs-type">T</span>&gt; &#123;<br>    message: <span class="hljs-type">UnsafeCell</span>&lt;<span class="hljs-type">MaybeUninit</span>&lt;<span class="hljs-type">T</span>&gt;&gt;,<br>    ready: <span class="hljs-type">AtomicBool</span>,<br>&#125;<br><br>unsafe impl<span class="hljs-operator">&lt;</span><span class="hljs-type">T</span><span class="hljs-operator">&gt;</span> <span class="hljs-type">Sync</span> <span class="hljs-keyword">for</span> <span class="hljs-type">Channel</span>&lt;<span class="hljs-type">T</span>&gt; <span class="hljs-keyword">where</span> <span class="hljs-type">T</span>: <span class="hljs-type">Send</span> &#123;&#125;<br><br>pub <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Sender</span>&lt;&#x27;a, <span class="hljs-type">T</span>&gt; &#123;<br>    channel: <span class="hljs-operator">&amp;</span>&#x27;a <span class="hljs-type">Channel</span>&lt;<span class="hljs-type">T</span>&gt;,<br>    recv_thread: <span class="hljs-type">Thread</span>,<br>&#125;<br><br>pub <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Receiver</span>&lt;&#x27;a, <span class="hljs-type">T</span>&gt; &#123;<br>    channel: <span class="hljs-operator">&amp;</span>&#x27;a <span class="hljs-type">Channel</span>&lt;<span class="hljs-type">T</span>&gt;,<br>    _marker: std::marker::<span class="hljs-type">PhantomData</span>&lt;&amp;&#x27;a <span class="hljs-type">T</span>&gt;,<br>&#125;<br><br>impl<span class="hljs-operator">&lt;</span><span class="hljs-type">T</span><span class="hljs-operator">&gt;</span> <span class="hljs-type">Channel</span>&lt;<span class="hljs-type">T</span>&gt; &#123;<br>    pub const fn new() -&gt; <span class="hljs-keyword">Self</span> &#123;<br>        <span class="hljs-keyword">Self</span> &#123;<br>            message: <span class="hljs-type">UnsafeCell</span>::new(MaybeUninit::uninit()),<br>            ready: <span class="hljs-type">AtomicBool</span>::new(<span class="hljs-literal">false</span>),<br>        &#125;<br>    &#125;<br><br>    pub fn split(<span class="hljs-operator">&amp;</span>mut <span class="hljs-keyword">self</span>) -&gt; (<span class="hljs-type">Sender</span>&lt;<span class="hljs-type">T</span>&gt;, <span class="hljs-type">Receiver</span>&lt;<span class="hljs-type">T</span>&gt;) &#123;<br>        <span class="hljs-operator">*</span><span class="hljs-keyword">self</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">Self</span>::new();<br>        (<br>            <span class="hljs-type">Sender</span> &#123;<br>                channel: <span class="hljs-keyword">self</span>,<br>                recv_thread: thread::current(),<br>            &#125;,<br>            <span class="hljs-type">Receiver</span> &#123;<br>                channel: <span class="hljs-keyword">self</span>,<br>                _marker: std::marker::<span class="hljs-type">PhantomData</span>,<br>            &#125;,<br>        )<br>    &#125;<br>&#125;<br><br>impl<span class="hljs-operator">&lt;</span><span class="hljs-type">T</span><span class="hljs-operator">&gt;</span> <span class="hljs-type">Sender</span>&lt;&#x27;<span class="hljs-keyword">_</span>, <span class="hljs-type">T</span>&gt; &#123;<br>    pub fn send(<span class="hljs-keyword">self</span>, message: <span class="hljs-type">T</span>) &#123;<br>        unsafe &#123; (<span class="hljs-operator">*</span><span class="hljs-keyword">self</span>.channel.message.get()).write(message) &#125;;<br>        <span class="hljs-keyword">self</span>.channel.ready.store(<span class="hljs-literal">true</span>, <span class="hljs-type">Release</span>);<br>        <span class="hljs-keyword">self</span>.recv_thread.unpark();<br>    &#125;<br>&#125;<br><br>impl<span class="hljs-operator">&lt;</span><span class="hljs-type">T</span><span class="hljs-operator">&gt;</span> <span class="hljs-type">Receiver</span>&lt;&#x27;<span class="hljs-keyword">_</span>, <span class="hljs-type">T</span>&gt; &#123;<br>    pub fn is_ready(<span class="hljs-operator">&amp;</span><span class="hljs-keyword">self</span>) -&gt; bool &#123;<br>        <span class="hljs-keyword">self</span>.channel.ready.load(<span class="hljs-type">Relaxed</span>)<br>    &#125;<br><br>    pub fn receive(<span class="hljs-keyword">self</span>) -&gt; <span class="hljs-type">T</span> &#123;<br>        <span class="hljs-keyword">while</span> <span class="hljs-operator">!</span><span class="hljs-keyword">self</span>.channel.ready.swap(<span class="hljs-literal">false</span>, <span class="hljs-type">Acquire</span>) &#123;<br>            thread::park();<br>        &#125;<br>        unsafe &#123; (<span class="hljs-operator">*</span><span class="hljs-keyword">self</span>.channel.message.get()).assume_init_read() &#125;<br>    &#125;<br>&#125;<br><br>impl<span class="hljs-operator">&lt;</span><span class="hljs-type">T</span><span class="hljs-operator">&gt;</span> <span class="hljs-type">Drop</span> <span class="hljs-keyword">for</span> <span class="hljs-type">Channel</span>&lt;<span class="hljs-type">T</span>&gt; &#123;<br>    fn drop(<span class="hljs-operator">&amp;</span>mut <span class="hljs-keyword">self</span>) &#123;<br>        <span class="hljs-keyword">if</span> <span class="hljs-operator">*</span><span class="hljs-keyword">self</span>.ready.get_mut() &#123;<br>            unsafe &#123; <span class="hljs-keyword">self</span>.message.get_mut().assume_init_drop() &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>Pay attention to these points:</p>
<ol>
<li>Use <code>MaybeUninit</code> to save memory.</li>
<li>Abstract <code>Sender</code> and <code>Receiver</code> to limit the user’s access to the channel.(Think about the <code>MutexGuard</code> in <code>Mutex</code>)</li>
<li>Use thread handle to park / unpark the receiver thread.</li>
<li>Do not forget to drop the <code>MaybeUninit</code> due to the struct won’t drop the inner data automatically.</li>
</ol>
<h2 id="Arc">Arc</h2>
<ul>
<li>
<p>snippet 1:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">ArcData</span>&lt;T&gt; &#123;<br>    ref_cnt: AtomicUsize,<br>    data: T,<br>&#125;<br><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Arc</span>&lt;T&gt; &#123;<br>    data: NonNull&lt;ArcData&lt;T&gt;&gt;,<br>&#125;<br><br><span class="hljs-keyword">unsafe</span> <span class="hljs-keyword">impl</span>&lt;T: <span class="hljs-built_in">Send</span> + <span class="hljs-built_in">Sync</span>&gt; <span class="hljs-built_in">Send</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">Arc</span>&lt;T&gt; &#123;&#125;<br><span class="hljs-keyword">unsafe</span> <span class="hljs-keyword">impl</span>&lt;T: <span class="hljs-built_in">Send</span> + <span class="hljs-built_in">Sync</span>&gt; <span class="hljs-built_in">Sync</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">Arc</span>&lt;T&gt; &#123;&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li><code>NonNull</code> is almost same as <code>*mut T</code> but non-null and [covariant]</li>
<li><code>Arc&lt;T&gt;</code> should be shared between threads, so <code>T</code> should be <code>Sync</code>.</li>
<li><code>Arc&lt;T&gt;</code> could be dropped by other threads, so <code>T</code> should be <code>Send</code>.</li>
</ul>
</li>
<li>
<p>snippet 2:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">impl</span>&lt;T&gt; Arc&lt;T&gt; &#123;<br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">new</span>(data: T) <span class="hljs-punctuation">-&gt;</span> Arc&lt;T&gt; &#123;<br>        Arc &#123;<br>            ptr: NonNull::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-type">Box</span>::<span class="hljs-title function_ invoke__">leak</span>(<span class="hljs-type">Box</span>::<span class="hljs-title function_ invoke__">new</span>(ArcData &#123;<br>                ref_count: AtomicUsize::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-number">1</span>),<br>                data,<br>            &#125;))),<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">data</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> &amp;ArcData&lt;T&gt; &#123;<br>        <span class="hljs-keyword">unsafe</span> &#123; <span class="hljs-keyword">self</span>.ptr.<span class="hljs-title function_ invoke__">as_ref</span>() &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">impl</span>&lt;T&gt; Deref <span class="hljs-keyword">for</span> <span class="hljs-title class_">Arc</span>&lt;T&gt; &#123;<br>    <span class="hljs-keyword">type</span> <span class="hljs-title class_">Target</span> = T;<br><br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">deref</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> &amp;T &#123;<br>        &amp;<span class="hljs-keyword">self</span>.<span class="hljs-title function_ invoke__">data</span>().data<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>Use <code>Box::leak</code> to give up the exclusive ownership of a <code>Box</code> allocation.</li>
</ul>
</li>
<li>
<p>snippet 3:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">impl</span>&lt;T&gt; <span class="hljs-built_in">Clone</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">Arc</span>&lt;T&gt; &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">clone</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-keyword">Self</span> &#123;<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">self</span>.<span class="hljs-title function_ invoke__">data</span>().ref_count.<span class="hljs-title function_ invoke__">fetch_add</span>(<span class="hljs-number">1</span>, Relaxed) &gt; <span class="hljs-type">usize</span>::MAX / <span class="hljs-number">2</span> &#123;<br>            std::process::<span class="hljs-title function_ invoke__">abort</span>();<br>        &#125;<br>        Arc &#123; ptr: <span class="hljs-keyword">self</span>.ptr &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">impl</span>&lt;T&gt; <span class="hljs-built_in">Drop</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">Arc</span>&lt;T&gt; &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">drop</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) &#123;<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">self</span>.<span class="hljs-title function_ invoke__">data</span>().ref_count.<span class="hljs-title function_ invoke__">fetch_sub</span>(<span class="hljs-number">1</span>, Release) == <span class="hljs-number">1</span> &#123;<br>            <span class="hljs-title function_ invoke__">fence</span>(Acquire);<br>            <span class="hljs-keyword">unsafe</span> &#123;<br>                <span class="hljs-title function_ invoke__">drop</span>(<span class="hljs-type">Box</span>::<span class="hljs-title function_ invoke__">from_raw</span>(<span class="hljs-keyword">self</span>.ptr.<span class="hljs-title function_ invoke__">as_ptr</span>()));<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li><code>fetch_add</code> and <code>fetch_sub</code> are used to increment and decrement the reference count.</li>
<li><code>fetch_add</code> is <code>Relaxed</code> because we don’t need to guarantee the order of the reference count, but pay attention to the next line.</li>
<li><code>fetch_sub</code> is <code>Release</code> and then <code>fence(Acquire)</code> to make sure no one is still accessing the data when we drop it.<br>
We need to guarantee that <strong>all the previous</strong> <code>fetch_sub</code> <strong><u>happens before</u></strong> the <strong>final</strong> <code>fetch_sub</code>.<br>
In hence, we can use <code>AcqRel</code> for that, however, only the final decrement needs <code>Acquire</code>, so we use <code>Release</code> + <code>fence(Acquire)</code> for efficiency.</li>
</ul>
</li>
</ul>
<p>Futher more, if we want to handle ‘self-reference’ struct with <code>Arc</code>, it might cause memory leak, because the <code>Arc</code> will only be dropped when the reference count is zero while self-reference struct will never be zero:</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> std::sync::&#123;Arc, Mutex&#125;;<br><br><span class="hljs-meta">#[derive(Debug)]</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">MyStruct</span> &#123;<br>    value: <span class="hljs-type">String</span>,<br>    self_ref: <span class="hljs-type">Option</span>&lt;Arc&lt;Mutex&lt;MyStruct&gt;&gt;&gt;,<br>&#125;<br><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">MyStruct</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">new</span>(value: <span class="hljs-type">String</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-keyword">Self</span> &#123;<br>        MyStruct &#123;<br>            value,<br>            self_ref: <span class="hljs-literal">None</span>,<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">set_reference</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, other: Arc&lt;Mutex&lt;MyStruct&gt;&gt;) &#123;<br>        <span class="hljs-keyword">self</span>.self_ref = <span class="hljs-title function_ invoke__">Some</span>(other);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Drop</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">MyStruct</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">drop</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;MyStruct is dropped&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">DetectDrop</span> &#123;&#125;<br><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Drop</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">DetectDrop</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">drop</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) &#123;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;DetectDrop is dropped&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">a</span> = Arc::<span class="hljs-title function_ invoke__">new</span>(Mutex::<span class="hljs-title function_ invoke__">new</span>(MyStruct::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-string">&quot;Hello&quot;</span>.<span class="hljs-title function_ invoke__">to_string</span>())));<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">_b</span> = Arc::<span class="hljs-title function_ invoke__">new</span>(DetectDrop &#123;&#125;);<br><br>    &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">a_ref</span> = a.<span class="hljs-title function_ invoke__">lock</span>().<span class="hljs-title function_ invoke__">unwrap</span>();<br>        a_ref.<span class="hljs-title function_ invoke__">set_reference</span>(a.<span class="hljs-title function_ invoke__">clone</span>());<br>    &#125;<br><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;Arc count: &#123;&#125;&quot;</span>, Arc::<span class="hljs-title function_ invoke__">strong_count</span>(&amp;a));<br>&#125;<br><br><span class="hljs-comment">// OUTPUT:</span><br><span class="hljs-comment">// Arc count: 2</span><br><span class="hljs-comment">// DetectDrop is dropped</span><br></code></pre></td></tr></table></figure>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/tech/" class="category-chain-item">tech</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/Rust/" class="print-no-link">#Rust</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>Rust Atomics and Locks</div>
      <div>https://kayce.world/tech/rust_atomics_and_locks/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>Author</div>
          <div>kayce</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>Posted on</div>
          <div>December 18, 2024</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>Updated on</div>
          <div>December 18, 2024</div>
        </div>
      
      
        <div class="license-meta-item">
          <div>Licensed under</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - Attribution">
                    <i class="iconfont icon-cc-by"></i>
                  </span>
                </a>
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">
                  <span class="hint--top hint--rounded" aria-label="NC - Non-commercial">
                    <i class="iconfont icon-cc-nc"></i>
                  </span>
                </a>
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">
                  <span class="hint--top hint--rounded" aria-label="SA - Share-alike">
                    <i class="iconfont icon-cc-sa"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/dessert/double_entry_bookkeeping/" title="「甜点」：复式记账法">
                        <span class="hidden-mobile">「甜点」：复式记账法</span>
                        <span class="visible-mobile">Next</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
  
  
    <article id="comments" lazyload>
      
  <div id="gitalk-container"></div>
  <script type="text/javascript">
    Fluid.utils.loadComments('#gitalk-container', function() {
      Fluid.utils.createCssLink('/css/gitalk.css')
      Fluid.utils.createScript('https://lib.baomitu.com/gitalk/1.8.0/gitalk.min.js', function() {
        var options = Object.assign(
          {"clientID":"b25aa0a3d88c5fc4dbeb","clientSecret":"485e76d306112a519d43b4118efa8971c3ff6069","repo":"sshelll.github.io","owner":"sshelll","admin":["sshelll"],"language":"en-US","labels":["Gitalk"],"perPage":10,"pagerDirection":"last","distractionFreeMode":false,"createIssueManually":true,"proxy":"https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token"},
          {
            id: 'fbe76afe27bb9370648eaef592bf7f6f'
          }
        )
        var gitalk = new Gitalk(options);
        gitalk.render('gitalk-container');
      });
    });
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


    </article>
  


          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>Table of Contents</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  


  
  









    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">Search</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">Keyword</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
      <a>kayce</a>
    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="busuanzi_container_site_pv" style="display: none">
        Views: 
        <span id="busuanzi_value_site_pv"></span>
        
      </span>
    
    
      <span id="busuanzi_container_site_uv" style="display: none">
        Visitors: 
        <span id="busuanzi_value_site_uv"></span>
        
      </span>
    
    

  

</div>

  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  
      <script>
        if (!window.MathJax) {
          window.MathJax = {
            tex    : {
              inlineMath: { '[+]': [['$', '$']] }
            },
            loader : {
              load: ['ui/lazy']
            },
            options: {
              renderActions: {
                insertedScript: [200, () => {
                  document.querySelectorAll('mjx-container').forEach(node => {
                    let target = node.parentNode;
                    if (target.nodeName.toLowerCase() === 'li') {
                      target.parentNode.classList.add('has-jax');
                    }
                  });
                }, '', false]
              }
            }
          };
        } else {
          MathJax.startup.document.state(0);
          MathJax.texReset();
          MathJax.typeset();
          MathJax.typesetPromise();
        }

        Fluid.events.registerRefreshCallback(function() {
          if ('MathJax' in window && MathJax.startup.document && typeof MathJax.startup.document.state === 'function') {
            MathJax.startup.document.state(0);
            MathJax.texReset();
            MathJax.typeset();
            MathJax.typesetPromise();
          }
        });
      </script>
    

  <script  src="https://lib.baomitu.com/mathjax/3.2.2/es5/tex-mml-chtml.js" ></script>

  <script  src="/js/local-search.js" ></script>

  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">Blog works best with JavaScript enabled</div>
  </noscript>
</body>
</html>
